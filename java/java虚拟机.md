# Java虚拟机

---

## java虚拟机是什么？

可能指：

1、抽象规范。

2、一个具体的实现。基于规范的实现。

**3、一个运行中的虚拟机实例。**

每个java程序都运行于某个具体的java虚拟机实例上。

运行三个java程序，就将得到三个java虚拟要实例。每个java程序都运行于它自己的java虚拟机中。

## java虚拟机线程

有两种，一种守护线程，一种非守护线程，当所有非守护线程终止，那么程序将终止。

# java虚拟机体系结构

## 运行时数据区

### 线程共享的：

#### 	方法区 :

​	用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机规范把方法区描述为堆的一个逻辑部分。也称为**非堆**。

​	jdk7.0以前方法区是由java堆的永久代实现的，jdk8.0以后方法区是由元数据区代替。

​	包括运行时常量池，

#### 	堆：

​	java虚拟机所管理的内存中最大的一块，几乎所有的对象实例都在这分配内存。

​	gc堆，对象实例以及数组在堆上分配。

### 线程隔离的：

#### 	虚拟机栈：

​	描述java方法执行的内存模型，每个方法在执行的同时，都会创建一个栈帧，用于存局部变量表、操作数栈、动态链接、方法出口等信息。

#### 	本地方法栈：

​	用于为虚拟机执行java方法服务。也可以抛出StackOverflowError和OutOfMemoryError异常。

#### 	程序计数器：

​	用于指示程序下一条需要执行的java字节码命令。

# 对象

## 创建过程

遇到new指令

1、首先去检查这个指令的参数是否能在常量池中定位一个类的符号引用;

2、检查这个引用代表的类是否已被加载、解析和初始化过;

3、如果没有，则先执行相应的类加载过程。

4、为新生对象分配内存。划分可用空间和同步锁定空间分配。

5、初始化分配到的内存空间为零，除了对象头以外。

6、设置对象头信息，如对象对应哪个类，元数据信息，哈希码，gc分代年龄等

## 内存布局

3块区域：对象头，实例数据，对齐填充。

### 对象头

#### 对象的标记信息：

如哈希码，GC分代年龄，锁状态，持有的锁等

#### 类型指针：

即对象指向它的类元数据的指针

### 实例数据

类定义，及字段内容。

### 对齐填充

并不是必然存在，起着占位符作用。

hotspot vm内存管理要求对象起始地址必须是8字节的整数倍。

## 访问过程

通过虚拟机栈或本地方法栈上的reference数据来操作堆上的具体引用对象。

使用句柄和直接指针的方式访问。

句柄就是有个地方装指针，要访问对象时先找到句柄指针再在句柄中找对象指针。

## 内存分配

### 新生代

新对象在这里分配。

Eden区和2个Survivor区（from,to）;

分配对象内存先在Eden中;

如果Eden内存不够再分到from中;

Eden中对象经回收复制到to中，每回收一次如果仍然存活则增加一岁;

当to中满了则移到老年代。

### 老年代

大对象直接进入老年代，避免在回收中大量复制。

长期存活对象进入老年代。

#### 动态对象年龄判定

当Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，则年龄大于等于该年龄的对象就可以直接进入老年代。

# 垃圾回收

## 判断对象已死

### 引用计数法（主流jvm没用）

难以解决循环引用问题

### 可达性分析

通过一系列gc roots对象作为起点，向下搜索，看对象是否可达。

GC roots包括：

虚拟机栈中本地变量表中引用对象;

方法区中类静态属性相用的对象;

方法区中常量引用的对象;

本地方法栈中JNI引用的对象。

## 执行清理

1、若不可达，则会被第一次标记并进行一次筛选（判断是否有必要执行finalize()方法，否：没有覆盖finalize方法或该方法已经被虚拟机调用过）。

2、上一步如果判定为是，那么该对象会被放在F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。

补充：

对象如果在finalize()中重新与引用链任何一个对象建立关联则可以不被清理。

任何一个对象finalize()方法只会被系统自动调用一次。

## 引用类型

#### 强引用

如 Object obj=new Object()

如果引用在则不会回收掉被引用的对象。

#### 软引用

用来描述一此非必须的对象。对内存溢出前会将其进行回收。

#### 弱引用

下一次垃圾收集就会被回收。

#### 虚引用

无法通过这个引用来获取一个对象实例，只是关联一个对象使得在它被回收时收到一个系统通知。

## 方法区回收

### 回收常量

没有任何类或对象，引用这个常量就回收。

### 回收类

不存在该类的实例

加载该类的ClassLoader已经被回收

该类对应的java.lang.Class对象没有在任何地方补引用，即没有用反射访问该类的方法。

## 回收算法

### 标记-清除

用于老生代

### 复制

收集算法，用于新生代

### 标记整理

用于新生代

### 分代收集

针对不同的代，用不同的算法

# 状态监控

## jps

## jstat

## jinfo

## jmap

## jhat

## jstack

## hsdis

## jconsole

## visualvm